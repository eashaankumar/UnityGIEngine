#include "HLSLSupport.cginc"
#include "UnityShaderVariables.cginc"
#include "RayPayload.hlsl"
#include "Utils.hlsl"

#pragma max_recursion_depth 10
//#pragma enable_ray_tracing_shader_debug_symbols

// Input
RaytracingAccelerationStructure g_SceneAccelStruct;
float4x4 								g_InvViewMatrix;
float4x4 								g_ViewMatrix;
float3                                  g_SunDir;
float                                   g_Zoom;
float                                   g_dt;
float                                   g_SunIntensity;
int                                     g_seed;
TextureCube<float4>                     g_EnvTex;
SamplerState                            sampler_linear_repeat;

// Output
RWTexture2D<float4> 					g_PrimateRayOutput;
RWTexture2D<float4> 					g_PrimateSkyboxOutput;
RWTexture2D<float4> 					g_PrimateNormalDepth;
RWTexture2D<float4> 					g_DirectDiffuse;
RWTexture2D<float4> 					g_IndirectDiffuse;
RWTexture2D<float4> 					g_WorldPosBuffer;
RWTexture2D<float4> 					g_MotionBuffer;
RWTexture2D<float4> 					g_Emissive;

float lerp(float a, float b, float f)
{
    return a * (1.0 - f) + (b * f);
}

[shader("miss")]
void MainMissShader1_DiffuseRayInitial(inout RayPayload payload : SV_RayPayload)
{
    // skybox wipes all albedo and energy (since each ray is locally fired)
    float3 dir = WorldRayDirection();
    float d = saturate(dot(dir, g_SunDir));
    float4 light =0;
    float sunsize = 0.5;
    if (d > 0)
    {
        if (d > 1-sunsize)
        {
            light = lerp(0, 1, 1.0-(1-sunsize)/d) * g_SunIntensity;
        }
    }

	payload.energy = g_EnvTex.SampleLevel(sampler_linear_repeat, WorldRayDirection(), 0);
    payload.worldPos.w = 0;
}

[shader("miss")]
void MainMissShader2_Shadow(inout RayPayloadShadow payload : SV_RayPayload)
{
    // The ray "hit" the light.
	payload.shadowValue = 1;//1.0;
}

void TracePrimateRay(inout float shadowVal)
{
    uint2 LaunchIndex = DispatchRaysIndex().xy;
    uint2 LaunchDim = DispatchRaysDimensions().xy;

    float2 frameCoord = float2(LaunchIndex.x, LaunchDim.y - LaunchIndex.y - 1) + float2(0.5, 0.5);

    // The ray origin is the camera position in world space.
    float3 rayOrigin = float3(g_InvViewMatrix[0][3], g_InvViewMatrix[1][3], g_InvViewMatrix[2][3]);

    float2 ndcCoords = frameCoord / float2(LaunchDim.x - 1, LaunchDim.y - 1);
        
    ndcCoords = ndcCoords * 2 - float2(1, 1);
    ndcCoords = ndcCoords * g_Zoom;

    float aspectRatio = (float)LaunchDim.x / (float)LaunchDim.y;

    float3 viewDirection = normalize(float3(ndcCoords.x * aspectRatio, ndcCoords.y, -1));

    // Rotate the ray from view space to world space.
    float3 rayDirection = normalize(mul((float3x3)g_InvViewMatrix, viewDirection));

    RayDesc ray;
    ray.Origin = rayOrigin;
    ray.Direction = rayDirection;
    ray.TMin = 0;
    ray.TMax = 1e10f;
        
    RayPayload payload;   
    payload.rayType = 0;
    payload.primateNormal = float3(0, 0, 0);
    payload.primateColor = float4(0, 0, 0, 0);
    payload.color = float4(0, 0, 0, 0);
    payload.worldPos = float4(0, 0, 0, 1);
	payload.bounceIndex = 0;
    payload.didHitSpecular = 0;

    TraceRay(g_SceneAccelStruct, 0, 0xFF, 0, 1, 0, ray, payload);

    // ignore skybox, just raw albedo

    g_PrimateRayOutput[frameCoord] = payload.primateColor;
    if (payload.bounceIndex == 0)
        g_PrimateSkyboxOutput[frameCoord] = payload.energy;
    else
        g_PrimateSkyboxOutput[frameCoord] = 0;

    // vel buffer calculations
    float4 prevPos = g_WorldPosBuffer[frameCoord]; 
    float4 pos = payload.worldPos;
    //float3 a = pos.xyz / pos.w;
    //float3 b = prevPos.xyz / prevPos.w;
    g_MotionBuffer[frameCoord] = prevPos;//float4((a-b) , 1);
    g_WorldPosBuffer[frameCoord] = pos;

    float4 normalDepth = 0;
    normalDepth.xyz = payload.primateNormal;
    normalDepth.w = 1.0 / distance(payload.worldPos.xyz, rayOrigin);
    g_PrimateNormalDepth[frameCoord] = normalDepth;

    g_Emissive[frameCoord] = payload.energy;

    bool didHit = payload.bounceIndex > 0;
    float3 firstHitPos = payload.worldPos.xyz;
    // relfection albedo
    if (didHit * payload.didHitSpecular > 0.0)
    {
        ray.Origin = payload.bounceRayOrigin;
        ray.Direction = payload.bounceRayDir;
        payload.rayType = 0;
        payload.energy = 0;
        payload.color = 0;
        payload.bounceIndex = 0;
        payload.specular = 0;
        TraceRay(g_SceneAccelStruct, 0, 0xFF, 0, 1, 0, ray, payload);
        g_PrimateRayOutput[frameCoord] *= lerp((payload.color + payload.energy), 1.0, payload.specular) + lerp((payload.color + payload.energy), 1.0, 1.0-payload.specular);
    }

    shadowVal = 1;
    // shadow ray
    if (didHit)
    {
        RayDesc shadowRay;
        shadowRay.Origin = firstHitPos + -g_SunDir * 0.1; // K_RAY_ORIGIN_PUSH_OFF
        shadowRay.Direction = g_SunDir;
        shadowRay.TMin = 0;
        shadowRay.TMax = 10000000;
        
        RayPayloadShadow payloadShadow;
        payloadShadow.shadowValue = 0.7;
    
        const uint missShaderForShadowRay = 1;
        TraceRay(g_SceneAccelStruct, RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH | RAY_FLAG_SKIP_CLOSEST_HIT_SHADER | RAY_FLAG_CULL_BACK_FACING_TRIANGLES, 0xFF, 0, 1, missShaderForShadowRay, shadowRay, payloadShadow);

        if (payload.worldPos.w == 1)
        {
            g_PrimateRayOutput[frameCoord] *= payloadShadow.shadowValue;
            shadowVal = 0;
        }
    }
}

float Attentuate(float3 worldPos, float rayOrigin, float fraction)
{
    return exp(-length(worldPos - rayOrigin) * fraction);
}

void TraceDirectDiffuse(float2 rng, inout float4 directDiffuseGI, inout float4 indirectDiffuseGI)
{
    // Direct Diffuse (Sunlight only)
    int2 launchIndex = uint2(DispatchRaysIndex().x, DispatchRaysDimensions().y - DispatchRaysIndex().y - 1);
    uint2 launchDim = DispatchRaysDimensions().xy;

    // Shoot rays through the center of a pixel (plus a jitter).
    float2 frameCoord = launchIndex + float2(0.5, 0.5);
     // Initial random number generator seed for this pixel. The rngState will change every time we draw a random number.
    
    int convergenceStep = 0;
    uint g_FrameIndex = 0;
    uint rngState = uint(uint(launchIndex.x) * uint(g_seed + 1973) + uint(launchIndex.y) * uint(g_seed + 9277) + uint(convergenceStep + g_FrameIndex) * uint(g_seed + 26699)) | uint(1);

    float2 jitter = float2(RandomFloat01(rngState), RandomFloat01(rngState)) + rng - float2(0.5, 0.5);
    float2 ndcCoords = (frameCoord + jitter) / float2(launchDim.x - 1, launchDim.y - 1);

    ndcCoords = ndcCoords * 2 - float2(1, 1);
    ndcCoords = ndcCoords * g_Zoom;

    float aspectRatio = (float)launchDim.x / (float)launchDim.y;

    float3 viewDirection = normalize(float3(ndcCoords.x * aspectRatio, ndcCoords.y, -1));

    // Rotate the ray from view space to world space.
    float3 rayOrigin = float3(g_InvViewMatrix[0][3], g_InvViewMatrix[1][3], g_InvViewMatrix[2][3]);
    float3 rayDirection = normalize(mul((float3x3)g_InvViewMatrix, viewDirection));
    
    uint missShaderIndex = 0;
    RayDesc ray;
    ray.Origin = rayOrigin;
    ray.Direction = rayDirection;
    ray.TMin = 0;
    ray.TMax = 1e10f;
        
    RayPayload payload;   
    payload.rayType = 1;
    payload.bounceRayOrigin = float3(0, 0, 0);
    payload.bounceRayDir = float3(0, 0, 0);
    payload.primateNormal = float3(0, 0, 0);
    payload.primateColor = float4(0, 0, 0, 0);
    payload.color = float4(1, 1, 1, 1);
    payload.worldPos = float4(0, 0, 0, 1);
    payload.energy = 0;
	payload.bounceIndex = 0;
    payload.rngState = rngState;
    
    // first lets get back to the object contact point
    TraceRay(g_SceneAccelStruct, 0, 0xFF, 0, 1, missShaderIndex, ray, payload);
    
    directDiffuseGI = payload.energy * Attentuate(payload.worldPos.xyz, ray.Origin, 10);
    indirectDiffuseGI = 0;

    float4 allColors = payload.color;

    
    if (payload.bounceIndex > 0)
    {
        uint bounceIndex = payload.bounceIndex;
        RandomFloat01(payload.rngState);
        ray.Origin = payload.bounceRayOrigin;
        ray.Direction = payload.bounceRayDir;
        payload.rayType = 1;
        payload.energy = 0;
        TraceRay(g_SceneAccelStruct, 0, 0xFF, 0, 1, missShaderIndex, ray, payload);
        directDiffuseGI += payload.energy * Attentuate(payload.worldPos.xyz, ray.Origin, 0.001);
        allColors *= payload.color;
        
        if (payload.bounceIndex > 1)
        {
            payload.rayType = 2;
            RandomFloat01(payload.rngState);
            ray.Origin = payload.bounceRayOrigin;
            ray.Direction = payload.bounceRayDir;
            payload.energy = 0;
            TraceRay(g_SceneAccelStruct, 0, 0xFF, 0, 1, missShaderIndex, ray, payload);

            indirectDiffuseGI = (allColors + directDiffuseGI) * payload.energy * Attentuate(payload.worldPos.xyz, ray.Origin, 10);            
        }
        else
        {
            indirectDiffuseGI = float4(0, 0, 0, 0);
        }
    }
    else
    {
        directDiffuseGI = float4(0, 0, 0, 0);
    }
}


[shader("raygeneration")]
void MainRayGenShader()
{ 
	uint2 LaunchIndex = DispatchRaysIndex().xy;
    uint2 LaunchDim = DispatchRaysDimensions().xy;

    float2 frameCoord = float2(LaunchIndex.x, LaunchDim.y - LaunchIndex.y - 1) + float2(0.5, 0.5);
    float shadowValue;
    TracePrimateRay(shadowValue);
    
    float4 directDiffuseGI;
    float4 indirectDiffuseGI;

    int spp = 2;
    float rngX = 0;
    float rngY = 0;
    for(int i = 0; i < spp; i++)
    {
        float4 directDiffuseGITemp;
        float4 indirectDiffuseGITemp;
        // TODO: I am not sure if I am getting the rng rand generation right...Is it doing anything?
        float2 rng = float2(RandomFloat01(rngX), RandomFloat01(rngY));
        TraceDirectDiffuse(rng,directDiffuseGITemp, indirectDiffuseGITemp);

        directDiffuseGI += directDiffuseGITemp;
        indirectDiffuseGI += indirectDiffuseGITemp;
    }
    float4 emissive = g_Emissive[frameCoord];
    g_DirectDiffuse[frameCoord] = lerp((directDiffuseGI / spp - emissive), g_DirectDiffuse[frameCoord], 0.4);
    g_IndirectDiffuse[frameCoord] = (indirectDiffuseGI / spp - emissive) * 0.9 + g_IndirectDiffuse[frameCoord] * 0.1;

    /*float2 rng = float2(RandomFloat01(rngX), RandomFloat01(rngY));
    TraceDirectDiffuse(rng,directDiffuseGI, indirectDiffuseGI);

    float4 emissive = g_Emissive[frameCoord];
    g_DirectDiffuse[frameCoord] = (directDiffuseGI / spp - emissive);*/
}
