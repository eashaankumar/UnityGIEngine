#include "HLSLSupport.cginc"
#include "UnityShaderVariables.cginc"
#include "RayPayload.hlsl"
#include "Utils.hlsl"

#pragma max_recursion_depth 10
//#pragma enable_ray_tracing_shader_debug_symbols

// Input
RaytracingAccelerationStructure g_SceneAccelStruct;
float4x4 								g_InvViewMatrix;
float4x4 								g_ViewMatrix;
float                                   g_Zoom;
TextureCube<float4>                     g_EnvTex;
SamplerState                            sampler_linear_repeat;

// Output
RWTexture2D<float4> 					g_PrimateRayOutput;
RWTexture2D<float4> 					g_PrimateNormalDepth;

[shader("miss")]
void MainMissShader1_Primary(inout RayPayload payload : SV_RayPayload)
{
	payload.color = 0;//g_EnvTex.SampleLevel(sampler_linear_repeat, WorldRayDirection(), 0) * 1;
    payload.worldPos.w = 0;
}

[shader("miss")]
void MainMissShader2_Shadow(inout RayPayloadShadow payload : SV_RayPayload)
{
    // The ray "hit" the light.
	payload.shadowValue = 0;//1.0;
}

void TracePrimateRay()
{
    uint2 LaunchIndex = DispatchRaysIndex().xy;
    uint2 LaunchDim = DispatchRaysDimensions().xy;

    float2 frameCoord = float2(LaunchIndex.x, LaunchDim.y - LaunchIndex.y - 1) + float2(0.5, 0.5);

    // The ray origin is the camera position in world space.
    float3 rayOrigin = float3(g_InvViewMatrix[0][3], g_InvViewMatrix[1][3], g_InvViewMatrix[2][3]);

    float2 ndcCoords = frameCoord / float2(LaunchDim.x - 1, LaunchDim.y - 1);
        
    ndcCoords = ndcCoords * 2 - float2(1, 1);
    ndcCoords = ndcCoords * g_Zoom;

    float aspectRatio = (float)LaunchDim.x / (float)LaunchDim.y;

    float3 viewDirection = normalize(float3(ndcCoords.x * aspectRatio, ndcCoords.y, -1));

    // Rotate the ray from view space to world space.
    float3 rayDirection = normalize(mul((float3x3)g_InvViewMatrix, viewDirection));

    RayDesc ray;
    ray.Origin = rayOrigin;
    ray.Direction = rayDirection;
    ray.TMin = 0;
    ray.TMax = 1e10f;
        
    RayPayload payload;   
    payload.rayType = 0;
    payload.primateNormal = float3(0, 0, 0);
    payload.primateColor = float4(0, 0, 0, 0);
    payload.color = float4(0, 0, 0, 0);
    payload.worldPos = float4(0, 0, 0, 1);
	payload.bounceIndex = 0;
    
    TraceRay(g_SceneAccelStruct, 0, 0xFF, 0, 1, 0, ray, payload);

    g_PrimateRayOutput[frameCoord] = payload.primateColor;

    float4 normalDepth = 0;
    normalDepth.xyz = payload.primateNormal;
    normalDepth.w = 1.0 / distance(payload.worldPos.xyz, rayOrigin);
    g_PrimateNormalDepth[frameCoord] = normalDepth;
}

void TraceDirectDiffuse()
{
    // Direct Diffuse (Sunlight only)
    int2 launchIndex = uint2(DispatchRaysIndex().x, DispatchRaysDimensions().y - DispatchRaysIndex().y - 1);
    uint2 launchDim = DispatchRaysDimensions().xy;

    // Shoot rays through the center of a pixel (plus a jitter).
    float2 frameCoord = launchIndex + float2(0.5, 0.5);
     // Initial random number generator seed for this pixel. The rngState will change every time we draw a random number.
    
    int convergenceStep = 0;
    uint g_FrameIndex = 0;
    uint rngState = uint(uint(launchIndex.x) * uint(1973) + uint(launchIndex.y) * uint(9277) + uint(convergenceStep + g_FrameIndex) * uint(26699)) | uint(1);

    float2 jitter = float2(RandomFloat01(rngState), RandomFloat01(rngState)) - float2(0.5, 0.5);
    float2 ndcCoords = (frameCoord + jitter) / float2(launchDim.x - 1, launchDim.y - 1);

    ndcCoords = ndcCoords * 2 - float2(1, 1);
    ndcCoords = ndcCoords * g_Zoom;

    float aspectRatio = (float)launchDim.x / (float)launchDim.y;

    float3 viewDirection = normalize(float3(ndcCoords.x * aspectRatio, ndcCoords.y, -1));

    // Rotate the ray from view space to world space.
    float3 rayOrigin = float3(g_InvViewMatrix[0][3], g_InvViewMatrix[1][3], g_InvViewMatrix[2][3]);
    float3 rayDirection = normalize(mul((float3x3)g_InvViewMatrix, viewDirection));

    RayDesc ray;
    ray.Origin = rayOrigin;
    ray.Direction = rayDirection;
    ray.TMin = 0;
    ray.TMax = 1e10f;
        
    RayPayload payload;   
    payload.rayType = 0;
    payload.primateNormal = float3(0, 0, 0);
    payload.primateColor = float4(0, 0, 0, 0);
    payload.color = float4(0, 0, 0, 0);
    payload.worldPos = float4(0, 0, 0, 1);
	payload.bounceIndex = 0;
    
    TraceRay(g_SceneAccelStruct, 0, 0xFF, 0, 1, 0, ray, payload);
    g_PrimateRayOutput[frameCoord] = payload.primateColor;
}

[shader("raygeneration")]
void MainRayGenShader()
{ 
	uint2 LaunchIndex = DispatchRaysIndex().xy;
    uint2 LaunchDim = DispatchRaysDimensions().xy;

    float2 frameCoord = float2(LaunchIndex.x, LaunchDim.y - LaunchIndex.y - 1) + float2(0.5, 0.5);
    TracePrimateRay();
    
    // debug
    //g_PrimateRayOutput[frameCoord] = g_PrimateNormalDepth[frameCoord].w;

    TraceDirectDiffuse();
    
    // Shadow ray
    /*float3 vecToLight = PointLightPosition - payload.worldPos.xyz;
    float vecToLightLength = length(PointLightPosition - payload.worldPos.xyz);
    float3 vecToLightNorm = normalize(vecToLight);

    RayDesc shadowRay;
    shadowRay.Origin = payload.worldPos.xyz + vecToLightNorm * 0.001f;
    shadowRay.Direction = vecToLightNorm;
    shadowRay.TMin = 0;
    shadowRay.TMax = vecToLightLength;
        
    RayPayloadShadow payloadShadow;
    payloadShadow.shadowValue = 0.5f;
    
    const uint missShaderForShadowRay = 1;
    TraceRay(g_SceneAccelStruct, RAY_FLAG_ACCEPT_FIRST_HIT_AND_END_SEARCH | RAY_FLAG_SKIP_CLOSEST_HIT_SHADER | RAY_FLAG_CULL_BACK_FACING_TRIANGLES, 0xFF, 0, 1, missShaderForShadowRay, shadowRay, payloadShadow);

    if (payload.worldPos.w == 1)
        finalColor *= payloadShadow.shadowValue;
    */
}
