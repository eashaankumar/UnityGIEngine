using System.Collections.Generic;
using System.Linq;
using Unity.Mathematics;
using UnityEngine;

namespace DreamPhysics
{
    public class BoxSATSolver
    {

        public struct ContactPoint
        {
            public Vector3 point;
            public Vector3 normal;
            public float penDepth;
        }

        public void Solve(DreamBox firstB, DreamBox secondB, List<ContactPoint> cps, out int bestCase)
        {
            var axes = GetAxis(firstB, secondB);
            var toCenter = secondB.Position - firstB.Position;
            float pen = float.MaxValue;
            bestCase = -1;
            int bestSingleAxis = -1;
            for(int i = 0; i < 15; i++)
            {
                Vector3 axis = axes[i];

                // check for axis generated by almost parallel edges
                if (axis.sqrMagnitude < 1e-3f) continue;

                axis.Normalize();

                float overlap = PenetrationOnAxis(firstB, secondB, axis, toCenter);
                if (overlap < 0) return;
                if (overlap < pen)
                {
                    pen = overlap;
                    bestCase = i;
                    if (i < 6) bestSingleAxis = i;
                }
            }
            //Debug.Log($"[{Time.time}] Internal: {bestCase} ");

            if (bestCase < 0 || bestCase >= axes.Length) return; 

            if (bestCase < 3)
            {
                ResolveVertexFaceBoxBoxContact_Clipping(firstB, secondB, bestCase, toCenter, pen, cps);
            }
            else if (bestCase < 6)
            {
                ResolveVertexFaceBoxBoxContact_Clipping(secondB, firstB, bestCase - 3, -toCenter, pen, cps);
            }
            else
            {
                ResolveEdgeEdgeBoxBoxContact(firstB, secondB, bestCase - 6, bestSingleAxis, pen, toCenter, cps);
            }
        }

        void ResolveVertexFaceBoxBoxContact_Clipping(DreamBox one, DreamBox two, int bestCase, Vector3 toCenter, float pen, List<ContactPoint> cps)
        {
            // http://web.archive.org/web/20160101163908/https://bullet.googlecode.com/files/GDC10_Coumans_Erwin_Contact.pdf
            ///
            /// Identify reference face (contact normal)
            /// Identify incident face
            /// Clip incident face against reference face side planes (but not the reference face)
            /// Consider clip points that actually penetrate
            ///
            Vector3 refNormal = one.GetAxis(bestCase);
            if (Vector3.Dot(refNormal, toCenter) < 0)
            {
                refNormal *= -1;
            }

            Vector3 CalculateIncNormal(Vector3 toCenter, int axis)
            {
                var incNormal = two.GetAxis(axis);
                if (Vector3.Dot(incNormal, toCenter) > 0)
                {
                    incNormal *= -1;
                }
                return incNormal;
            }
            var incNormal0 = CalculateIncNormal(toCenter, 0);
            var incNormal1 = CalculateIncNormal(toCenter, 1);
            var incNormal2 = CalculateIncNormal(toCenter, 2);

            var incRefAlign0 = Vector3.Dot(refNormal, incNormal0);
            var incRefAlign1 = Vector3.Dot(refNormal, incNormal1);
            var incRefAlign2 = Vector3.Dot(refNormal, incNormal2);

            var incNormal = Vector3.zero;
            var bestCaseInc = 0;

            bool isLeastAlign(float t, float a, float b) => t < a && t < b;

            if (isLeastAlign(incRefAlign0, incRefAlign1, incRefAlign2)) 
            {
                bestCaseInc = 0;
                incNormal = incNormal0;
            }
            else if (isLeastAlign(incRefAlign1, incRefAlign0, incRefAlign2)) 
            {
                bestCaseInc = 1;
                incNormal = incNormal1;
            }
            else if (isLeastAlign(incRefAlign2, incRefAlign1, incRefAlign0)) 
            {
                bestCaseInc = 2;
                incNormal = incNormal2;
            }

            var planeComp = Vector3.Dot(refNormal, incNormal);
            if (Mathf.Abs(planeComp) <  1e-5f) 
            {
                Debug.LogError("Reference and incident planes are orthogonal!");
                // incident plane is wrong, should never happen
                
            }



            var dimMask_cube1 = one.GetFaceSize(bestCase, out var localA_cube1, out var localB_cube1, out var cube1_nsize, out var cube1_nlocal);
            var dimMask_cube2 = two.GetFaceSize(bestCaseInc, out var localA_cube2, out var localB_cube2, out var cube2_nsize, out var cube2_nlocal);

            var worldASize_cube1 = one.rb.TransformDirectionUnscaled(localA_cube1* dimMask_cube1/2);
            var worldBSize_cube1 = one.rb.TransformDirectionUnscaled(localB_cube1* dimMask_cube1/2);
            var worldASize_cube2 = two.rb.TransformDirectionUnscaled(localA_cube2* dimMask_cube2/2);
            var worldBSize_cube2 = two.rb.TransformDirectionUnscaled(localB_cube2* dimMask_cube2/2);

            var refPolygon = PolygonCrossSectionSolver.NewPolygon();
            //float halfDimRef = math.length(one.Size/2 * (1-(float3)( math.abs(dimMask_cube1) <= 1e-10f))); // half extents on the reference normals axis of cube1 (dimMask_cube1 only gives non ones)
            Vector3 cube1_noff = refNormal * cube1_nsize/2;
            Vector3 cube2_noff = incNormal * cube2_nsize/2;

            Plane refPlane = new Plane(refNormal, cube1_noff + one.Position);
            Plane incPlane = new Plane(incNormal, cube2_noff + two.Position);

            refPolygon.AddEdge(one.Position + worldASize_cube1 + worldBSize_cube1 + cube1_noff, one.Position - worldASize_cube1 + worldBSize_cube1+ cube1_noff);
            refPolygon.AddEdge(one.Position - worldASize_cube1 + worldBSize_cube1+ cube1_noff, one.Position - worldASize_cube1 - worldBSize_cube1+ cube1_noff);
            refPolygon.AddEdge(one.Position - worldASize_cube1 - worldBSize_cube1+ cube1_noff, one.Position + worldASize_cube1 - worldBSize_cube1+ cube1_noff);
            refPolygon.AddEdge(one.Position + worldASize_cube1 - worldBSize_cube1+ cube1_noff, one.Position + worldASize_cube1 + worldBSize_cube1+ cube1_noff);


            var PA = two.Position + worldASize_cube2 + worldBSize_cube2 + cube2_noff;
            var projPA = refPlane.ClosestPointOnPlane(PA);
            var PB = two.Position - worldASize_cube2 + worldBSize_cube2+ cube2_noff;
            var projPB = refPlane.ClosestPointOnPlane(PB);
            var PC = two.Position - worldASize_cube2 - worldBSize_cube2+ cube2_noff;
            var projPC = refPlane.ClosestPointOnPlane(PC);
            var PD = two.Position + worldASize_cube2 - worldBSize_cube2+ cube2_noff;
            var projPD = refPlane.ClosestPointOnPlane(PD);
            refPolygon.AddEdge(projPA, projPB);
            refPolygon.AddEdge(projPB, projPC);
            refPolygon.AddEdge(projPC, projPD);
            refPolygon.AddEdge(projPD, projPA);

            refPolygon.DrawLines(Color.magenta);

            var incPolygon = PolygonCrossSectionSolver.NewPolygon();
            incPolygon.AddEdge(PA, PB);
            incPolygon.AddEdge(PB, PC);
            incPolygon.AddEdge(PC, PD);
            incPolygon.AddEdge(PD, PA);
            incPolygon.DrawLines(Color.cyan);

            ///
            /// This will return all points of interest that lie on the ref plane (projected points)
            /// Cull 
            ///
            var points = refPolygon.GetPolygonPoints();

            bool isOneOfProjectedPoints(Vector3 p)
            {
                return Mathf.Approximately(Vector3.SqrMagnitude(p - projPA), 0) || Mathf.Approximately(Vector3.SqrMagnitude(p - projPB), 0) ||
                        Mathf.Approximately(Vector3.SqrMagnitude(p - projPC), 0) || Mathf.Approximately(Vector3.SqrMagnitude(p - projPD), 0);
            }

            List<ContactPoint> reprojectPoints = new List<ContactPoint>();
            List<ContactPoint> secondaryPoints = new List<ContactPoint>();

            bool isParallelCase = Mathf.Approximately(Mathf.Abs(Vector3.Dot(incNormal, refNormal)), 1);
            foreach(var p in points)
            {
                // if p is one of the projected points, re-project back onto cube 2
                if (isOneOfProjectedPoints(p))
                {
                    // point-plane intersection
                    var ray = new Ray(p, -refNormal);
                    if (!incPlane.Raycast(ray, out var t)) 
                    {
                        //Debug.LogError("This should never happen...there should always be a reprojected point");
                        continue;
                    }
                    var actualCp = ray.GetPoint(t);
                    if (one.ContainsPoint(actualCp) && two.ContainsPoint(actualCp))
                    {
                        reprojectPoints.Add(new ContactPoint
                        {
                            point = actualCp,
                            penDepth = Mathf.Abs(t),
                            normal = refNormal
                        });
                    }
                }
                // else its either a cube 1 corner point or an insectional "stable" point
                // these points only become relevant in the || Face case or if one edge || face case
                else 
                {
                    var ray = new Ray(p, -refNormal);
                    if (!incPlane.Raycast(ray, out var t)) 
                    {
                        //Debug.LogError("This should never happen...there should always be a reprojected point");
                        continue;
                    }
                    var actualCp = ray.GetPoint(t);
                    if (one.ContainsPoint(actualCp) && two.ContainsPoint(actualCp))
                    {
                        secondaryPoints.Add(new ContactPoint
                        {
                            point = actualCp,
                            penDepth = t,
                            normal = refNormal
                        });
                    }
                }
                
            }

            List<ContactPoint> combinedList = new List<ContactPoint>(reprojectPoints.Concat(secondaryPoints));
            if (isParallelCase)
            {
                // add ALL the points
                HashSet<Vector3> visitedPoints = new HashSet<Vector3>();
                foreach(var p in combinedList)
                {
                    if (visitedPoints.Contains(p.point)) continue;
                    visitedPoints.Add(p.point);
                    cps.Add(p);
                }
            }
            else
            {
                // get best Pen from reprojected
                // get best Pen from secondary
                // find best best Pen
                // find partner of best best Pen (from both lists, if exists)
                // add best best pen AND its partner
                
                // find re-proj point with greatest pen
                float bestPen = float.MinValue;
                if (reprojectPoints.Count > 0)
                {
                    int i = BestPen(reprojectPoints);
                    bestPen = reprojectPoints[i].penDepth;
                }

                if (secondaryPoints.Count > 0)
                {
                    int i = BestPen(secondaryPoints);
                    bestPen = Mathf.Max(bestPen, secondaryPoints[i].penDepth);
                }

                if (Mathf.Approximately(bestPen, float.MinValue)) return;

                HashSet<Vector3> visitedPoints = new HashSet<Vector3>();
                FilterContactPoints(combinedList, visitedPoints, cps, bestPen);
            }

            

            Debug.DrawLine(one.Position, one.Position + cube1_noff, Color.green);
            Debug.DrawLine(two.Position, two.Position + cube2_noff, Color.blue);
        }

        int BestPen(List<ContactPoint> points)
        {
            int i = 0;
            for(int r = 0; r < points.Count; r++)
            {
                if (points[i].penDepth < points[r].penDepth)
                {
                    i = r;
                }
            }
            return i;
        }

        void FilterContactPoints(List<ContactPoint> points, HashSet<Vector3> visited, List<ContactPoint> filteredPoints, float filter)
        {
            for(int r = 0; r < points.Count; r++)
            {
                var cp = points[r];
                if (visited.Contains(cp.point)) continue;
                visited.Add(cp.point);
                if (Mathf.Approximately(cp.penDepth, filter))
                {
                    filteredPoints.Add(cp);
                }
            }
        }
        
        
        void ResolveEdgeEdgeBoxBoxContact(DreamBox one, DreamBox two, int best, int bestSingleAxis, float pen, Vector3 toCenter, List<ContactPoint> cps)
        {
            int oneAxisIndex = best / 3;
            int twoAxisIndex = best % 3;
            Vector3 oneAxis = one.GetAxis(oneAxisIndex);
            Vector3 twoAxis = two.GetAxis(twoAxisIndex);
            Vector3 axis = Vector3.Cross(oneAxis, twoAxis).normalized;

            // The axis should point from box one to box two
            if (Vector3.Dot(axis, toCenter) > 0) axis = -axis;

            Vector3 ptOnOneEdge = one.Size / 2;
            Vector3 ptOnTwoEdge = two.Size / 2;
            for(int i = 0; i < 3; i++)
            {
                if (i == oneAxisIndex) ptOnOneEdge[i] = 0;
                else if (Vector3.Dot(one.GetAxis(i), axis) > 0) ptOnOneEdge[i] = -ptOnOneEdge[i];

                if (i == twoAxisIndex) ptOnTwoEdge[i] = 0;
                else if (Vector3.Dot(two.GetAxis(i), axis) < 0) ptOnTwoEdge[i] = -ptOnTwoEdge[i];
            }

            // Move them into world coordinates (they are already oriented
            // correctly, since they have been derived from the axes).
            ptOnOneEdge = one.rb.TransformPointUnscaled(ptOnOneEdge);
            ptOnTwoEdge = two.rb.TransformPointUnscaled(ptOnTwoEdge);

            // So we have a point and a direction for the colliding edges.
            // We need to find out point of closest approach of the two
            // line-segments.
            Vector3 vertex = ClosestApproachOfCollidingEdges(
                ptOnOneEdge, oneAxis, one.Size[oneAxisIndex]/2,
                ptOnTwoEdge, twoAxis, two.Size[twoAxisIndex]/2,
                bestSingleAxis > 2, out var isMidpoint
            );

            cps.Add(new ContactPoint
            {
                normal = axis,
                penDepth = pen,
                point = isMidpoint ? vertex - axis * pen/2 : vertex
            });
        }

        Vector3[] GetAxis(DreamBox first, DreamBox second)
        {
            Vector3[] axis = new Vector3[15];

            axis[0] = first.GetAxis(0);
            axis[1] = first.GetAxis(1);
            axis[2] = first.GetAxis(2);

            axis[3] = second.GetAxis(0);
            axis[4] = second.GetAxis(1);
            axis[5] = second.GetAxis(2);

            axis[6] = Vector3.Cross(first.GetAxis(0), second.GetAxis(0)).normalized;
            axis[7] = Vector3.Cross(first.GetAxis(0), second.GetAxis(1)).normalized;
            axis[8] = Vector3.Cross(first.GetAxis(0), second.GetAxis(2)).normalized;

            axis[9] = Vector3.Cross(first.GetAxis(1), second.GetAxis(0)).normalized;
            axis[10] = Vector3.Cross(first.GetAxis(1), second.GetAxis(1)).normalized;
            axis[11] = Vector3.Cross(first.GetAxis(1), second.GetAxis(2)).normalized;

            axis[12] = Vector3.Cross(first.GetAxis(2), second.GetAxis(0)).normalized;
            axis[13] = Vector3.Cross(first.GetAxis(2), second.GetAxis(1)).normalized;
            axis[14] = Vector3.Cross(first.GetAxis(2), second.GetAxis(2)).normalized;
            return axis;
        }

        float PenetrationOnAxis(DreamBox first, DreamBox second, Vector3 axis, Vector3 toCenter)
        {
            float oneProject = TransformToAxis(first, axis);
            float secondProject = TransformToAxis(second, axis);

            float distance = Mathf.Abs(Vector3.Dot(toCenter, axis));    

            // return overlap (+ overlap, - separation)
            return oneProject + secondProject - distance;
        }

        float TransformToAxis(DreamBox b, Vector3 axis)
        {
            // https://github.com/idmillington/cyclone-physics/blob/master/src/collide_fine.cpp
            var halfExtents = b.Size / 2;
            return
                halfExtents.x * Mathf.Abs(Vector3.Dot(axis, b.GetAxis(0))) +
                halfExtents.y * Mathf.Abs(Vector3.Dot(axis, b.GetAxis(1))) +
                halfExtents.z * Mathf.Abs(Vector3.Dot(axis, b.GetAxis(2)));
        }

        Vector3 ClosestApproachOfCollidingEdges(
                Vector3 pOne,
                Vector3 dOne,
                float oneSize,
                 Vector3 pTwo,        
                 Vector3 dTwo,
                float twoSize,

                    // If this is true, and the contact point is outside
                    // the edge (in the case of an edge-face contact) then
                    // we use one's midpoint, otherwise we use two's.
                bool useOne,
                out bool midPoint)
            {
            Vector3 toSt, cOne, cTwo;
            float dpStaOne, dpStaTwo, dpOneTwo, smOne, smTwo;
            float denom, mua, mub;

            smOne = dOne.sqrMagnitude;
            smTwo = dTwo.sqrMagnitude;
            dpOneTwo = Vector3.Dot(dTwo, dOne);

            toSt = pOne - pTwo;
            dpStaOne = Vector3.Dot(dOne, toSt);
            dpStaTwo = Vector3.Dot(dTwo, toSt);

            denom = smOne* smTwo - dpOneTwo* dpOneTwo;

            // Zero denominator indicates parrallel lines
            if (Mathf.Abs(denom) < 0.0001f) {
                midPoint = false;
                return useOne? pOne:pTwo;
            }

            mua = (dpOneTwo* dpStaTwo - smTwo* dpStaOne) / denom;
            mub = (smOne* dpStaTwo - dpOneTwo* dpStaOne) / denom;

            // If either of the edges has the nearest point out
            // of bounds, then the edges aren't crossed, we have
            // an edge-face contact. Our point is on the edge, which
            // we know from the useOne parameter.
            if (mua > oneSize ||
                mua< -oneSize ||
                mub> twoSize ||
                mub< -twoSize)
            {
                midPoint = false;
                return useOne? pOne:pTwo;
            }
            else
            {
                cOne = pOne + dOne * mua;
                cTwo = pTwo + dTwo * mub;
                midPoint = true;
                return cOne * 0.5f + cTwo * 0.5f;
            }
        }
    }
}
